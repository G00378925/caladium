\chapter{System Evaluation}
% Evaluate your project against the objectives set out in the introduction.
% This chapter should present results if applicable
% and discuss the strengths and weaknesses of your system.
% This is a clear opportunity for you to demonstrate your
% critical thinking in relation to the project.

In this chapter, I will be evaluating my project against the
objectives I set out in the introduction.
I will be also discussing good areas and places that don't work as well as they should.

\section{Detecting Malware}
\subsection{Dynamic Analysis}
The main goal of this project is to detect malicious software.
To achieve this, administrators can add malicious patterns through the dashboard.
These patterns are then passed to the workers when a scan task is created.
The software is executed, and its system calls are collected
and compared against malicious patterns.
If any of the system calls contain one of the patterns,
then they can be deemed malicious.

To test the dynamic analysis compile the C program found below
(use a compiler such as GCC or Clang).

It creates a file called "very\_malicious.txt" when executed,
and this file name to the malicious patterns before scanning the executable.

Have the client application scan this file,
use the manual scan on the main page.
When scanned, the system successfully detected the file as malicious.

\begin{lstlisting}[language=C]
#include <windows.h>

#define FILE_NAME "very_malicious.txt"

int main(int argc, char *argv[]) {
    DeleteFileA(FILE_NAME);
    CreateFile(FILE_NAME, GENERIC_WRITE, 0, NULL,
        CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);

    return 0;
}
\end{lstlisting}

\subsection{Static Analysis}
The main goal of the project was to develop a platform capable
of detecting malicious software based on its behaviour.
This was done by executing the software in a sandboxed
environment and logging the system calls.
And then comparing the system calls to a list of malicious patterns.
When I searched for databases on the internet of known malicious patterns,
I didn't find many results, so I opted to include static analysis as well as a fallback.

As static analysis is a tried and true method of detecting malware,
there is a plethora of definitions for malicious patterns.

\section{User Experience}

\section{Stability}
Weird behaviour

\section{Code Quality}

\subsection{Cyclomatic Complexity}
Cyclomatic complexity is a metric that measures how complex code is.
This can indicate that there may be too much code inside a class or method.

\texttt{Radon} is a tool that you can use to
calculate code complexity in your codebase.

By using the \texttt{radon cc client -a} command,
I was able to measure the Python code found in the client directory,
and it analyzed the code of 48 blocks,
including classes, functions, and methods.
The average complexity for the client was calculated as \texttt{A (2.3125)}.

I also ran the tool on the server and the average complexity
was calculated as \texttt{A (1.7567567567567568)}.

While these are good scores for code complexity,
it does not necessarily indicate good code readability.
Readability can be improved by using good variable names.

\subsection{Readability}

\section{Scaling}
The server is capable of handling multiple clients,
but there is only one instance of the server running.
This means in the event of the server crashing, clients will not be able to scan files.

The platform can handle multiple scans at the same time, as multiple workers are supported.

\section{Time Complexity}
When a file is executed by the worker it produces a log of all the
system calls it produces, a list of patterns is passed to
the worker in order to be checked against the system calls
if there is a match then the file can be deemed malicious.

This is a sample of the code from \texttt{sandbox/src/syscall\_analysis.py}
it has a O($n$ * $m$) time complexity, $n$ being the size of the syscalls
and $m$ being the size of the patterns\_list.
\begin{lstlisting}
def analysis_worker(syscall_queue, malicious_patterns):
  while True:
    # Fetch a syscall from the queue
    try: syscall = syscall_queue.get(timeout=1)
    except: break
    for pattern in malicious_patterns:
      # Check for a pattern match
      if pattern in syscall:
        # Detection . . .
\end{lstlisting}

As you can see above, if the malicious\_patterns list grows
significantly this would quickly become a bottleneck,
so the solution I found is doing the check-ing parallel,
each of the system calls would be added to a queue,
and a worker would fetch a syscall and then run it against all the patterns.

% % % % % % % % % % % % % % % % % % % %

\section{RESTful APIs}

% % % % % % % % % % % % % % % % % % % %

\section{Security}
As stated in the introductory chapter, the platform needs to be secure,
it would be rather hypocritical to ignore security in a
platform targeted at identifying malware

To get into the dashboard you must log in with a username and password.
The password is hashed using the SHA-256 algorithm.
If the server is compromised, the admin's password won't be readable.

When you log in you are given a session token which is stored in the browser's local storage.
All RESTful API calls require the session token to be sent with the request.

% https://owasp.org/www-community/attacks/xss/
\subsection{Cross Site Scripting (XSS)}
Cross-site scripting is a type of attack \cite{XSS},
where attacks can inject code into other users' browser sessions,
a field may show data to the screen, and attack input data containing HTML,
which doesn't get sanitised, In my project, I modified my code
after finding this security bug, to convert HTML to entity tags. 

\section {Design Principles}
I set out an objective to have the code in my project
adhere to good design principles
