% 00:36 12/04/2023
\chapter{System Evaluation}
% Evaluate your project against the objectives set out in the introduction.
% This chapter should present results if applicable
% and discuss the strengths and weaknesses of your system.
% This is a clear opportunity for you to demonstrate your
% critical thinking in relation to the project.

In this chapter, the project will be evaluated against the
objectives set out in the introduction.

\section{Detecting Malware}
\subsection{Dynamic Analysis}
The main goal of this project is to detect malicious software.
To achieve this, administrators can add malicious patterns through the dashboard.
These patterns are then passed to the workers when a scan task is created.
The software is executed, and its system calls are collected
and compared against the malicious patterns.
If any of the system calls contain one of the patterns,
then they can be deemed malicious.

To test the dynamic analysis, compile the C program provided below
(using a compiler such as GCC or Clang).
The program creates a file called "very\_malicious.txt" when executed,
and this file name is added to the malicious patterns
before scanning the executable.

Have the client application scan this file using
the manual scan option on the main page.
\textbf{Caladium successfully detected the file as being malicious.}

\begin{lstlisting}[language=C]
#include <windows.h>

#define FILE_NAME "very_malicious.txt"

int main(int argc, char *argv[]) {
    DeleteFileA(FILE_NAME);
    CreateFile(FILE_NAME, GENERIC_WRITE, 0, NULL,
        CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);

    return 0;
}
\end{lstlisting}

\subsection{Static Analysis}
The primary method of malware detection is dynamic analysis,
it uses static analysis as a fallback,
and uses ClamAV to facilitate this.

To test this, I am using the "EICAR Test File" \cite{EICAR},
which is a standardized file that is universally
detected as malware by all anti-malware solutions.

\textbf{Caladium successfully detects the file as malware.}

\subsection{Quarantine}
When the sandbox analysis worker detects the file being malware,
it will send a message back to the client indicating "malware\_detected".

The user in the client will then be prompted to quarantine the malware,
and the scan will finish.
The quarantined file can be found in the quarantine frame,
concluding that the quarantining feature works correctly.

\section{Code Quality}
I'm accessing the code quality on its cyclomatic complexity and how readable it is.

\subsection{Cyclomatic Complexity}
Cyclomatic complexity is a metric that measures how complex code is.
This can indicate that there may be too much code inside a class or method.

\texttt{Radon} is a tool that you can use to
calculate code complexity in your codebase.

By using the \texttt{radon cc client -a} command,
I was able to measure the Python code found in the client directory,
and it analyzed the code of 48 blocks,
including classes, functions, and methods.
The average complexity for the client was calculated as \texttt{A (2.3125)}.

I also ran the tool on the server and the average complexity
was calculated as \texttt{A (1.7567567567567568)}.

While these are good scores for code complexity,
it does not necessarily indicate good code readability.
Readability can be improved by using good variable names.

\subsection{Readability}
Throughout the development process,
I have made efforts to assign meaningful names to variables that reflect their purpose.
When applicable, I have also created functions to break up functionality,
which helps to keep the cyclomatic complexity low, as explained above.

In the GUI application, I have organized each frame into its own class,
such as the \texttt{QuarantineFrame}, which contains GUI-specific functionality.
The actual code for handling quarantine logic is placed in a separate \texttt{Quarantine} class.

I believe that implementing these measures has improved
the overall readability of the application.

\section{User Experience}
A user-friendly interface is provided to both users and
administrators through the client and the dashboard.

\subsection{Windows GUI Application}
Users simply need to run an installer,
which will automatically install and provision the software,
and start it on system boot.
It will immediately begin scanning the downloads directory,
and users can easily remove the software through the preferences menu.

The quarantine frame makes it easy for users to understand which
files are quarantined and allows them to easily quarantine new files.
Users also have the ability to modify the current scanning directory.

\subsection{Dashboard}
Administrators are prompted to log in to the dashboard and are
given the option to change their password in the
preferences menu once logged in.

Administrators can disable dynamic analysis in case it breaks,
and the system will fall back to static analysis.

The dashboard is a single-page application, with seamless switching
between pages without loading times.
The list pages allow administrators to easily add and remove clients or workers.

\section{RESTful APIs}
Clients communicate with the server using RESTful APIs.
Each of the endpoints is designed to be stateless,
meaning that the server does not need to maintain context.
HTTP methods such as \texttt{GET} and \texttt{POST} is used
to specify the type of action to be performed.

In the tasks endpoint, I am using the HTTP \texttt{DELETE}
method to delete records by their ID.

I have developed a suite of tests to test
the endpoints when the code is pushed to the repository.
Currently, all tests are passing. And I have also confirmed their functionality
as the GUI application is able to successfully scan files,
which relies on the APIs functioning correctly.

GitHub shows a green check mark when all the tests are passing.

\section{Security}
As stated in the introductory chapter, the platform needs to be secure,
it would be rather hypocritical to ignore security in a
platform targeted at identifying malware

\subsection{Authentication}
To get into the dashboard you must log in with a username and password.
The password is hashed using the SHA-256 algorithm.
If the server is compromised, the admin's password won't be readable.

When you log in you are given a session token which is stored in the browser's local storage.
All RESTful API calls require the session token to be sent with the request.

In the \texttt{\_\_main\_\_.py}, you can find a function
called \texttt{before\_request},
this gets called before every request, it checks the path being requested
and if the requester has the correct token to access the resource.

\subsection{Cross Site Scripting (XSS)}
Cross-site scripting is a type of attack \cite{XSS},
where attacks can inject code into other users' browser sessions,
a field may show data to the screen, and attack input data containing HTML,
which doesn't get sanitised, In my project, I modified my code
after finding this security bug, to convert HTML to entity tags. 

\section {Design Principles}
I set out an objective to have the code in my project
adhere to good design principles

Throughout the development, I tried to go by the DRY
(Do not Repeat Yourself) principle as much as possible.

This is evident in the Page hierarchy found in the dashboard,
where 

\section{Stability}
The platform functionality works very well, but I have noticed that there are unexpected problems when running over a network connection, I've tried to mitigate this by adding code to detect when a connection takes too long to run, or to detect exceptions, due to the unreliable nature of networks.

When designing a platform that makes use of different languages and computers, getting everything to work seamlessly is quite the challenge.

\section{Scaling}
The server is capable of handling multiple clients,
the platform was designed to make use of only one server,
but it is possible to have multiple instances of the server,
and have them all use the same CouchDB instance.

In the case of one server crashing one of the clients would still have the ability to scan files if they are using the other servers

The platform can handle multiple scans at the same time, as multiple workers are supported.

\section{Time Complexity}
When a file is executed by the worker it produces a log of all the
system calls it produces, a list of patterns is passed to
the worker in order to be checked against the system calls
if there is a match then the file can be deemed malicious.

This is a sample of the code from \texttt{sandbox/src/syscall\_analysis.py}
it has a O($n$ * $m$) time complexity, $n$ being the size of the syscalls
and $m$ being the size of the patterns\_list.
\begin{lstlisting}
def analysis_worker(syscall_queue, malicious_patterns):
  while True:
    # Fetch a syscall from the queue
    try: syscall = syscall_queue.get(timeout=1)
    except: break
    for pattern in malicious_patterns:
      # Check for a pattern match
      if pattern in syscall:
        # Detection . . .
\end{lstlisting}

As you can see above, if the malicious\_patterns list grows
significantly this would quickly become a bottleneck,
so the solution I found is doing the checking in parallel,
each of the system calls would be added to a queue,
and a worker would fetch a syscall and then run it against all the patterns.