% 13:52 06/04/2023
\chapter{Technology Review}
% This chapter is the literature review part of the dissertation
% and should be tightly coupled to the context and objective from the introduction.
% A thorough Technology Review proves that you researched what you were doing!
% https://ieeexplore.ieee.org/stamp/stamp.jsp?tp=&arnumber=4413008

This chapter provides a technical review of the technologies used in the platform.

Detailing the reasoning behind selecting these specific technologies
and how they contribute to accomplishing the objectives laid out in the introduction.

Also covering technologies specifically related to malware detection,
these include Sandboxie and Process Monitor,
and widely accepted standards like JSON for transmitting data over networks.

Lastly, it shows how the use of tooling like Docker
can help with the creation of reproducible environments.

First, the technologies that are general to all the sub-projects will be shown,
and what was used to create the chatbot for the promotional page.
Then the technologies that were used in each sub-project.

\section{JSON}
In the platform, there will be multiple computers that receive and transmit data.
There needs to be an agreed-upon format between these
computers in which the data is encoded.
The format must support dictionaries and lists to express data structures.

JSON has been chosen for this because the browser has
native support for encoding and decoding JSON,
Python supports it through the JSON module, and Racket also supports it.

JSON stands for JavaScript Object Notation,
a widely-used format for transmitting and storing data.

It provides a standardized way of serializing complex data structures or collections,
making it easy to transfer data between different systems.
JSON can be used to represent a wide range of data types,
including lists, dictionaries, and primitive types such as numbers and strings. \cite{ECMA-404}

Below you will find an example of JSON being used in the browser to encode a dictionary:

\begin{lstlisting}[language=Java]
const myData = {"1": 2, 3: 4.0}
console.log(JSON.stringify(myData));
\end{lstlisting}

And this is an example of it being used in Python, using the \texttt{json} module.

\begin{lstlisting}[language=Python]
import json

my_data = {"1": 2, 3: 4.0}
print(json.dumps(my_data))
\end{lstlisting}

\section{Python}
Python is an interpreted, high-level, general-purpose programming language.
I chose to use Python because I wanted to use the same language for the client and server.
When I serialised data in the client I could use the same
deserialisation function on the server.

Python is also a very simple language and is interpreted,
this allowed me to quickly test code, without having to compile it every time.

Python comes with a package manager called \texttt{pip},
which is accessible on all operating systems,
this allows me to easily install dependencies required by the server.

\section{GPT-3.5}
In recent months, the popularity of large language models has exploded,
primarily due to the advent of ChatGPT.

OpenAI, the creator of GPT, provides an API to their GPT-3.5 model.
This model has been trained on a large corpus of text from the internet
and can make predictions based on inputs to the model.

Currently, this technology represents the state of the art in
artificial intelligence and OpenAI's API make it freely available to anyone.

To promote the platform, I have created a promotional page on
my GitHub pages and added a bot (CaladiumBot) that can answer questions about it.
I fetch the latest version of the \texttt{README.md} file for
this project, feed it into the OpenAI model as an initial prompt,
and then use it to answer users' questions about the platform.

OpenAI provides a module for Python,
below you will find a minimal example of how I'm using it.
The full implementation can be found in \texttt{/bot/\_\_main\_\_}.

\begin{lstlisting}[language=Python]
import openai # Set OpenAI API key as environmental variable
openai.api_key = os.environ.get("OPENAI_API_KEY", None)

initial_prompt = """
You are CaladiumBot, you will answer questions
about the README listed below:
"""
# Append the README here

prompt = [{"role": "system", "content": initial_prompt}]
question = input("Your question: ")
prompt += [{"role": "user", "content": question}]

# This will output the GPT response to the command-line
print(openai.ChatCompletion.create(model="gpt-3.5-turbo", \
        messages=prompt).choices[0].message.content)
\end{lstlisting}

\section{Technology in the Client Side}
As stated in the objectives, there will be a native GUI application,
this will be a Windows application and will not run in the browser,
the language was chosen to create the client in Python,
so I am using Python-specific libraries to achieve this.

\subsection{PyInstaller}
A common reason why more people don't opt to use Python over a
native language such as C/C++ is the fact you require Python,
to run the code, some users that would like to use the software might 
want to be able to install your software without having to install Python.

Pyinstaller is a module for Python that allows you to bundle your
Python code with a Python interpreter, allowing it to be run on any
a computer that doesn't have Python installed.
This allows your software to be self-contained and portable,
users don't have to install Python on their computer to install your software.

\subsection{Tkinter}
Tkinter is the standard GUI library for Python,
It is also cross-platform, allowing the client to run on Windows, Linux and macOS.
It is stable and mature, with a plethora of documentation to be found on the internet.

Tkinter makes it very easy to create a GUI, allowing developers to quickly prototype code
I will give an example below,
of creating a simple GUI window.

\begin{lstlisting}[language=Python]
import tkinter

main_window = tkinter.Tk()
main_window.mainloop()
\end{lstlisting}

\subsection{tkthread}
In Tkinter applications, there exists an infinite \textbf{mainloop}
(as seen in the example above)
that runs until the user closes the application.

Whenever a user clicks a button,
it triggers an event that calls the corresponding callback function
that was specified during the button's creation.

As this call blocks the \textbf{mainloop}'s execution,
a function that takes a long time to complete,
invoked by the callback can cause the GUI to freeze,
causing the program to become unresponsive.

While a naive solution might involve threading,
this approach demands thread synchronization and can lead to race conditions
and ghost threads, leading to even more problems that it fixes.

Instead, tkthread provides a more elegant solution.

\subsection{JavaScript}
JavaScript was used in the dashboard to add dynamicity,
it is used to fetch data from the server using the RESTful API endpoints
and display it to the screen.

I wanted to take full advantage of all the new JavaScript features that were brought in
recent years these include the ability to have classes and the new fetch function as an alternative to setting up the XMLHttpRequest object.

The 6th edition of the ECMAScript standard \cite{ES6} (JavaScript standard) 
introduced the class keyword for creating classes,
before this developers had to create classes through prototypes.
\begin{lstlisting}[language=Java]
class Page {
    int x;

    constructor(newX) {
        this.x = x;
    }

    getX() {
        return this.x;
    }

    setX(newX) {
        this.x = newX;
    }
}
\end{lstlisting}

Here is the legacy syntax, as can be seen, it is quite verbose,
and it isn't encapsulated in the class like above.

\begin{lstlisting}[language=Java]
function Page(newX) {
    this.x = newX;
}

Page.prototype.getX = function() {
    return this.x
}

Page.prototype.setX = function(newX) {
    this.x = newX;
}
\end{lstlisting}

Another addition of the ECMAScript 2015 is the \texttt{fetch} function,
prior to this, you'd have to use the \texttt{XMLHttpRequest} object,
this is important in Caladium because it allows the dashboard to
request data from the server through the RESTful APIs.

I'm using the \texttt{fetch} function to request data from the server,
It is much simpler than using the legacy XMLHttpRequest API.

\begin{lstlisting}[language=Java]
const caladiumFetchParameters = {
    method: method, headers: {"Authorisation": localStorage["Authorisation"]},
    body: body ? JSON.stringify(body) : undefined
};
const resp = await fetch(path, caladiumFetchParameters);
return await resp.json();
\end{lstlisting}

\section{Technology in the Server}
The server is the main component of the platform,
bridging communication between the client and the sandbox instances, 
and providing RESTful APIs for the client to interact with it.

The server needs to be able to persist data from administrators, 
which is stored in CouchDB. Since the server is written in Python,
it requires the pymongodb library to communicate with the DB instance.

Additionally, I have created a \texttt{Dockerfile} for Docker
that enables people to easily replicate the required
environment for running the server.

\subsection{Flask}
I needed a way for the dashboard and the client to be
able to communicate with the server
I decided to use Flask to create the HTTP endpoints.

Flask is a micro web framework written in Python.
It is classified as a micro-framework because it does
not require particular tools or libraries.
This allowed me to create the HTTP endpoints for the RESTful API without
having to worry about the underlying HTTP server.

Below you will find some example code to create a Flask server,
with a GET endpoint that returns "\texttt{Index Page}" on request.

\begin{lstlisting}[language=Python]
import flask

app = flask.Flask(__name__)

app.get("/")
def root_page(): return "Index Page"

app.run()
\end{lstlisting}

\subsection{Representational State Transfer}

\subsection{CouchDB}
CouchDB is a document-oriented NoSQL database.
An important feature of any platform for many users is the
ability to be able to persist data.

In my case, I was using CouchDB to store the records for the
\textbf{clients}, \textbf{patterns}, \textbf{tasks} and \textbf{workers} tables.

I find NoSQL quite convenient compared to SQL databases,
because I don't have to write out the queries,
and NoSQL allows you to easily append JSON objects to the tables.

I went with CouchDB because the simplistic nature of a document database is appealing,
allowing me to spend more time on more complex features.

CouchDB provides an HTTP/JSON API, allowing any programming language
with an HTTP library to interface with the DB instance.

\subsection{pycouchdb}
Python alone isn't able to communicate with the CouchDB instance,
and requires a library in this case it's \textbf{pycouchdb}.

\subsection{Docker}
Docker is a tool used by developers to create reproducible environments.
Meaning you can run your software on different computers,
and it would have the exact same stuff installed.

Most open-source projects come with a \texttt{Dockerfile} this provides
users interested in setting up the project on their own computer,
with the same environment, the developers used.

The \texttt{Dockerfile} contains instructions for the Docker daemon,
this is a program that must be installed on a computer you wish to use Docker on.
You must then build containers using this file,
you can have multiple containers on one machine,
this is equivalent to having different computers with different Linux distributions.

You must then run these containers, and this will execute the code of the project.
These containers are isolated from the main system, and cannot edit files on the host system.
I am using Docker to make it easy to test my project on different machines,
allowing me to delete them easily,
and not have to actually install the dependencies on my main host system.

The \texttt{Dockerfile} I am using in my project can be found here:
\texttt{server/Dockerfile}

The Dockerfile begins by instructing the daemon,
to install the Linux Debian bullseye version.
Then refresh the apt-get package manager,
and install Python and the Python pip package manager.
Installs the required Python modules,
and copy the server files into the \texttt{/caladium} directory.

Then when you execute the container,
it runs the \texttt{\_\_main\_\_.py} on port 8080.

\begin{lstlisting}
FROM debian:bullseye

RUN apt-get update -y
RUN apt-get install python3 python3-pip -y

RUN python3 -m pip install flask pycouchdb requests

WORKDIR /caladium

COPY src/ /caladium

ENTRYPOINT ["python3"]
CMD ["__main__.py", "8080"]
\end{lstlisting}

\section{CouchDB}

\section{Technology in the Analysis Side}
In this section, I will be discussing the technology that
facilitates the scanning of files and the Racket programming language
I used to create the main part of the scanning side.

\subsection{Sandboxie}
Sandboxie is a tool for Microsoft Windows designed for sandboxing,
it provides a secure environment to run potentially malicious software.

Typical Windows applications, for example, your browsers like Chrome or Firefox,
never actually have direct access to your system's hard drive.
Instead, they have to go through the operating system, specifically the kernel,
to gain access. If the requesting applications lack the required permissions
the operating system can reject the request.

Sandboxie works by intercepting the system calls made by these applications
it then identifies the application that made the request,
if the process is currently running under Sandboxie,
it will fake a response, making the application think it was successful,
allowing us to observe its behaviour to its full extent.

The main purpose of using Sandboxie is to provide any
easy to use isolation software for users, to run software
without worrying about it harming the system.

Sandboxie provides plenty of documentation on how to use the software on its website,
and the utilities that come with the software come with command-line parameters,
allowing to interface with it programmatically.

Below you will find an example command of how to run the Windows
\textbf{notepad} in a sandbox:

\begin{lstlisting}
"%ProgramFiles%\Sandboxie\Start.exe" notepad.exe
\end{lstlisting}

\subsection{Process Monitor}
Process Monitor is a system monitoring program that allows you to log system calls.
It was created by Microsoft to serve as an advanced monitoring tool giving power users
the ability to see what exactly every process on their machine is doing,
it produces a log, of all the actions performed and the name of the process that did it.

I needed a way of finding out what the malware is doing,
so I decided to use Process Monitor to log system calls.
I originally was thinking of using a driver to log system calls,
but I decided to use Process Monitor instead to avoid reinventing the wheel.

\subsection{Racket}
Racket is a functional programming language.
I decided to program the main part of the analysis in Racket
because I've used a lot of Python in other components and
wanted to use a different programming language.

Functional programming languages encourage immutability,
this means once variables are set a value, then they can't be updated.
If you want to update a variable then you must create a new one with
the changes.

Racket comes with a plethora of documentation which can be found on its website.

\subsection{ClamAV}
ClamAV is an open-source anti-malware solution that
supports Windows, macOS and Linux.
This is the software I'm using to perform my static analysis.

Most anti-malware software are paid and/or closed source,
but ClamAV is the exception, on its website you can find a rich set of documentation,

My case was concerned with the \textbf{clamscan} command, and its parameters.
Most anti-malware solutions don't provide low-level access to their software
requiring you to use their menuing because that's who their target audience is.

ClamAV is targeted at power users,
giving them the ability to modify the source code,
and adding their own malware definitions.
