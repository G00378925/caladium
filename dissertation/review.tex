\chapter{Technology Review}
% This chapter is the literature review part of the dissertation
% and should be tightly coupled to the context and objective from the introduction.
% A thorough Technology Review proves that you researched what you were doing!

% https://ieeexplore.ieee.org/stamp/stamp.jsp?tp=&arnumber=4413008

This chapter provides a technical review of the technologies used in the platform.

Detailing my reasoning behind selecting these specific technologies
and how they contribute to accomplishing my objectives.

Also covering technologies specifically related to malware detection,
these include Sandboxie and Process Monitor,
and widely accepted standards like JSON for transmitting data over networks.

Lastly, it shows how the use of tooling like Docker
can help with the creation of reproducible environments.

\section{JSON}
In my platform, there will be multiple computers that receive and transmit data.
There needs to be an agreed-upon format between these computers in which the data is encoded.
The format must support dictionaries and lists to express data structures.

I have decided to use JSON for this because the browser has
native support for encoding and decoding JSON,
Python supports it through the JSON module, and Racket also supports it.

JSON stands for JavaScript Object Notation,
a widely-used format for transmitting and storing data.

It provides a standardized way of serializing complex data structures or collections,
making it easy to transfer data between different systems.
JSON can be used to represent a wide range of data types,
including lists, dictionaries, and primitive types such as numbers and strings. \cite{ECMA-404}

Below I will give an example of JSON being used in the browser to encode a dictionary:

\begin{lstlisting}[language=Java]
const myData = {"1": 2, 3: 4.0}
console.log(JSON.stringify(myData));
\end{lstlisting}

And this is an example of it being used in Python:

\begin{lstlisting}[language=Python]
import json

my_data = {"1": 2, 3: 4.0}
print(json.dumps(my_data))
\end{lstlisting}

\subsection{Python}
Python is an interpreted, high-level, general-purpose programming language.
I chose to use Python because I wanted to use the same language for the client and server.
When I serialised data in the client I could use the same deserialisation function on the server.

Python is also a very simple language and is interpreted, this allowed me to quickly test code, without having to compile it every time.

\section{Technology in the Client Side}
As stated in the objectives, there will be a native GUI application,
this will be a Windows application and will not run in the browser,
the language was chosen to create the client in Python,
so I am using Python-specific libraries to achieve this.

\subsection{Pyinstaller}
Pyinstaller is a module for Python that allows you to bundle your Python code with a Python interpreter, allowing it to be run on any computer that doesn't have Python installed.
This allows your software to be self-contained and portable, users don't have to install Python on their computer to install your software.

\subsection{Tkinter}
Tkinter is the standard GUI library for Python,
It is also cross-platform, allowing the client to run on Windows, Linux and macOS.
It is stable and mature, with a plethora of documentation to be found on the internet.

\subsection{tkthread}
In Tkinter applications, there exists a infinite \textbf{mainloop}
that runs until the user closes the application.

Whenever a user clicks a button,
it triggers an event that calls the corresponding callback function
that was specified during the button's creation.

As this call blocks the \textbf{mainloop}'s execution,
a function that takes a long time to complete,
invoked by the callback can cause the GUI to freeze,
causing the program to become unresponsive.

While a naive solution might involve threading,
this approach demands thread synchronization and can lead to race conditions
and ghost threads, leading to even more problems that it fixes.

Instead, Tkthread provides a more elegant solution.

\subsection{Dashboard}


\subsubsection{JavaScript}

\section{Technology in the Server}
\subsection{Flask}
I needed a way for the dashboard and the client to be able to communicate with the server
I decided to use Flask to create the HTTP endpoints.

Flask is a micro web framework written in Python.
It is classified as a micro-framework because it does not require particular tools or libraries.
This allowed me to create the HTTP endpoints for the RESTful API without having to worry about the underlying HTTP server.

\subsection{Docker}
To create a reproducible environment I decided to use Docker.
Docker is a containerization platform that allows you to create containers that can be run on any machine.
Docker is a platform that allows you to create containers that can be run on any machine.

All the instructions required to set up the environment are found in the Docker file, in my project this includes instructions to install libraries from the pip

The Dockerfile I am using in my project can be found here: \texttt{server/Dockerfile}

\subsection{CouchDB}
CouchDB is a document-oriented NoSQL database.
An important feature of any platform for many users is the
ability to be able to persist data.

I went with CouchDB because the simplistic nature of a document database is appealing,
allowing me to spend more time on more complex features

% % % % % % % % % %

\section{Technology in the Analysis Side}
In this section I will be discussing the technology that facilitates the scanning of the files and the racket programming language I used to create the main part of the scanning side.

\subsection{Sandboxie}
Sandboxie is a sandboxing program that allows you to run untrusted programs in a sandboxed environment.

The platform needs to be able to capture the behaviour of real malware,
without fear of it causing damage to the system it is running on.

% % % % % % % % % %

\subsection{Process Monitor}
Process Monitor is a system monitoring program that allows you to log system calls.
It was created by Microsoft to serve as an advanced monitoring tool giving power users
the ability to see what exactly every process on their machine is doing,
it produces a log, of all the actions performed and the name of the process that did it.


I needed a way of finding out what the malware is doing, so I decided to use Process Monitor to log system calls.
I originally was thinking of using a driver to log system calls, but I decided to use Process Monitor instead to avoid reinventing the wheel.

% % % % % % % % % %

\subsection{Racket}
Racket is a functional programming language. I decided to program the main part of the analysis in racket because I've used a lot of Python in other components and wanted to use a different programming language.

Functional programming languages encourage immutability,
this means once variables are set a value, then they can't be updated.
If you want to update a variable then you must create a new one with
the changes.

Racket comes with a plethora of documentation which can found on its website.

% % % % % % % % % %

\subsection{ClamAV}
ClamAV is an open-source anti-malware solution that
supports Windows, macOS and Linux.
This is the software I'm using to perform my static analysis.

Most anti-malware software are paid and/or closed source,
but ClamAV is the exception, on its website you can find a rich set of documentation,

In my case was concerned with the \textbf{clamscan} command, and its parameters.
Most anti-malware solution don't provide low level access to their software
requiring you to use their menuing because that's who their target audience is.

ClamAV is targeted at power users, giving them the ability to modify the source code,
and adding their own malware definitions.
